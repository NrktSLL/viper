"""
VIPER - Update Exploits Script

This script updates the database with public exploit information for all CVEs currently in the database.
It searches for exploits using the exploit_search_client and updates the database accordingly.
"""
import argparse
import logging
import os
import sys
import time
from datetime import datetime

from tqdm import tqdm

# Add project root to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from src.clients.exploit_search_client import find_public_exploits
from src.utils.database_handler import get_all_cve_ids_from_db, update_cve_exploit_data

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler(
            os.path.join(
                os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))),
                "logs",
                "exploit_update.log",
            )
        ),
    ],
)
logger = logging.getLogger(__name__)


def update_all_cves_with_exploit_info(max_cves=None, delay=2):
    """
    Updates all CVEs in the database with public exploit information.

    Args:
        max_cves (int, optional): Maximum number of CVEs to update, useful for testing. Default is None (all CVEs).
        delay (int, optional): Delay in seconds between API calls to avoid rate limiting. Default is 2.

    Returns:
        tuple: (total_updated, found_exploits) - number of CVEs updated and number with exploits found
    """
    # Get all CVE IDs from the database
    all_cve_ids = get_all_cve_ids_from_db()
    logger.info(f"Found {len(all_cve_ids)} CVEs in the database")

    if max_cves:
        all_cve_ids = all_cve_ids[:max_cves]
        logger.info(f"Limiting to {max_cves} CVEs for this run")

    total_updated = 0
    found_exploits = 0

    start_time = time.time()

    # Use tqdm for progress tracking
    for cve_id in tqdm(all_cve_ids, desc="Searching for exploits", unit="CVE"):
        try:
            # Search for exploits
            exploits = find_public_exploits(cve_id)

            # Update the database
            if update_cve_exploit_data(cve_id, exploits):
                total_updated += 1

                if exploits and len(exploits) > 0:
                    found_exploits += 1
                    logger.info(f"Found {len(exploits)} exploit(s) for {cve_id}")

            # Add delay to avoid rate limiting
            time.sleep(delay)

        except Exception as e:
            logger.error(f"Error updating exploit info for {cve_id}: {str(e)}")

    elapsed_time = time.time() - start_time
    logger.info(f"Exploit update completed in {elapsed_time:.2f} seconds")
    logger.info(f"Updated {total_updated} CVEs, found exploits for {found_exploits} CVEs")

    return total_updated, found_exploits


if __name__ == "__main__":
    # Set up command line arguments
    parser = argparse.ArgumentParser(description="Update VIPER database with public exploit information")
    parser.add_argument("--max-cves", type=int, help="Maximum number of CVEs to update (for testing)")
    parser.add_argument("--delay", type=float, default=2, help="Delay between API requests in seconds (default: 2)")
    args = parser.parse_args()

    logger.info("Starting exploit update process")
    logger.info(f"Time: {datetime.now().isoformat()}")

    # Create logs directory if it doesn't exist
    logs_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "logs")
    if not os.path.exists(logs_dir):
        os.makedirs(logs_dir)
        logger.info(f"Created logs directory at {logs_dir}")

    # Run the update
    total, found = update_all_cves_with_exploit_info(args.max_cves, args.delay)

    logger.info(f"Exploit update complete. Updated {total} CVEs, found exploits for {found} CVEs.")
    logger.info(f"Finished at: {datetime.now().isoformat()}")
